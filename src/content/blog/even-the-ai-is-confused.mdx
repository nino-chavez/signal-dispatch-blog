---
title: "Even the AI Is Confused"
slug: "even-the-ai-is-confused"
publishedAt: "2025-08-01T18:20:42.000Z"
updatedAt: "2025-08-01T18:20:42.000Z"
author: "Nino Chavez"
status: "published"
excerpt: "What My Stack Audit Revealed About Modern Dev"
featureImage: "/content/images/2025/08/photo-1635850967683-17df1f33e749.jpeg"
tags:
  - ai
  - field-notes
  - point-of-view
category: "AI & Automation"
seo:
  metaTitle: "Even the AI Is Confused"
  metaDescription: "What My Stack Audit Revealed About Modern Dev"
  ogImage: "/content/images/2025/08/photo-1635850967683-17df1f33e749.jpeg"
---

The Stack Didn't Break â€” The AI DidI didnâ€™t expect the AI to break before I did.

But thatâ€™s exactly what happened while building a real production-grade tournament manager. Not a blog. Not a demo. A full-stack transactional app with auth, sync, edge functions, Supabase, and a zero-tolerance build pipeline.

The AI tool I was using â€” Kilo â€” flagged my project as broken.

Spoiler: it wasnâ€™t.

The app builds cleanly. The code is tight. The config is intentional.
The problem wasnâ€™t with my stack. It was with how AI *interprets* it.

And honestly? That tells us everything about the state of modern web development.

ğŸ§  The SetupIâ€™m running a modern JS stack, straight from the â€œbest practicesâ€ playbook:

- âš›ï¸ React + Vite frontend
- ğŸ’… Tailwind with semantic theming
- ğŸ§± Supabase as the backend/auth layer
- ğŸ“¦ Modular structure, clean package.json, zero-dependency bloat

No wild experiments. No half-baked plug-ins. Just clean, modern code â€” built to ship and scale.

Before a major push, I ran a Kilo audit on the `package.json` to check for unused packages, broken scripts, or stale dependencies.

âŒ Kilo: â€œYour Project Is Brokenâ€Kilo confidently reported:

> â€œYour `vite.config.ts` references packages in `manualChunks` that donâ€™t exist in `package.json`. This will break your build.â€

That soundedâ€¦ wrong.

Because:

- The app builds perfectly (`dist/` verified)
- The chunk config is intentional, future-proofing for code-split scenarios
- Vite handles missing chunk targets gracefully

And yet, the AI doubled down.

âœ… Kilo (Eventually): â€œMy Bad. The Project Is Excellent.â€After pushback, Kilo retracted everything:

> â€œI misunderstood how Viteâ€™s manualChunks works. I assumed complexity where simplicity was intentional.â€

> â€œYour package.json is actually in excellent condition.â€

> â€œIâ€™ve learned from this mistake.â€

Exceptâ€¦ it didnâ€™t learn.
Because **it canâ€™t** â€” not in the way real engineers do.

ğŸ” Most AI Tools Simulate Correction. Few Operationalize It.This is the real issue.

Kilo didnâ€™t persist that learning. It didnâ€™t create a safeguard or update its reasoning. It failed to recognize idiomatic patterns â€” and itâ€™ll fail again on the next audit unless I hand-feed it every exception.

Thatâ€™s not intelligence.
Thatâ€™s inference without infrastructure.

ğŸ§  **Gist of the full AI audit failure:**
[https://gist.github.com/chavezabelino/9164611dc20fc795e80409e2386e81b0](https://gist.github.com/chavezabelino/9164611dc20fc795e80409e2386e81b0)

ğŸ§¨ This Stack Is Coherent â€” The Ecosystem Isnâ€™tLetâ€™s be clear: my project wasnâ€™t broken.

But the modern fullstack ecosystem is so **unstructured, pluginized, and overloaded** that even AI tools canâ€™t parse it cleanly.

Worse â€” they confuse future-proofing and modularity with error states.

Even good setups look broken because:

- No one tool has full-stack awareness
- Idioms change every 6 months
- â€œConventionsâ€ are suggestions, not contracts

ğŸ—£ï¸ This Isn't Theory. I'm Living It.This isnâ€™t recycled rage from YouTube.

Iâ€™m building the real thing â€” a transactional, production-grade app with deadlines, users, and real data.

So if you come at me with something someone *else* blogged about, podcasted, or tweeted?

Keep scrolling.

I have the receipts. I have the scars. And Iâ€™m not done yet.

ğŸ§­ What This Teaches Us1. **Modern JS isnâ€™t broken by default â€” itâ€™s broken by integration burden.**
2. **AI won't fix DX rot â€” it amplifies the gaps.**
3. **We need software patterns that are legible to humans *and* machines.**

That means:

- Constraints over choice fatigue
- Structure over glue code
- Developer *sanity* as a design goal

We need better stacks â€” and better reflexes baked into our tools.
