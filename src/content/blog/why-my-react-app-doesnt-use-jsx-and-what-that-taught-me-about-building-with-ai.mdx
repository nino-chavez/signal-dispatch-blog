---
title: "Why My React App Doesnâ€™t Use JSX (And What That Taught Me About Building with AI)"
publishedAt: "2025-08-02T16:39:00.000Z"
author: "Nino Chavez"
excerpt: "Most React apps are JSX-first."
category: "AI & Automation"
tags: ["architecture"]
featured: false
source: "linkedin"
linkedinUrl: "https://www.linkedin.com/pulse/why-my-react-app-doesnt-use-jsx-what-taught-me-building-nino-chavez-6e1ic"
---

### ðŸ§µ Behind-the-Scenes of an Unexpected UI Architecture

Most React apps are JSX-first.

Mine isnâ€™t.

That wasnâ€™t a bold opinion or a clever trick â€” itâ€™s just where I ended up after building a real system using AI as my primary coding partner.

Iâ€™m not a frontend dev. Iâ€™m a Java-native backend engineer who builds systems â€” not interfaces.

But I needed a UI. A real one. Something flexible, theme-aware, and programmatic â€” that could render brackets, matches, schedules, and metadata based on dynamic data and modes.

So I relied on AI to generate the frontend. And I trusted it to scaffold something â€œReact-idiomatic.â€

But what I got was React.createElement()â€¦ everywhere.

* * *

### ðŸ§  What I Was Actually Trying to Build

I wasnâ€™t setting out to write clean React code. I was trying to solve a **functional problem**:

-   Display evolving bracket and match data
    
-   Theme the UI based on light/dark/system modes
    
-   Support variants like ghost, elevated, interactive
    
-   Compose layouts from data, not by hand
    
-   Move fast using AI to scaffold large chunks of the interface
    

I wasnâ€™t trying to hand-craft components. I was trying to define the right **inputs** and let the UI be **rendered from logic**.

So when the AI kept reaching for React.createElement(), I didnâ€™t question it.

It made sense to me: it looked like factory-style composition. Explicit. Declarative. Composable. A little verbose, maybe â€” but very familiar if you come from Java.

* * *

### âš ï¸ Then TypeScript Got Involved

Everything â€œworkedâ€ â€” until I turned on strict mode.

Suddenly, the compiler lit up like a Christmas tree:

-   **1,096 TypeScript errors**
    
-   Nearly all traced back to React.createElement calls
    
-   The component props were valid, but TypeScript couldnâ€™t infer them properly
    
-   Variant-rich components like Button, Badge, and Card were totally broken in the type system
    

This wasnâ€™t a logic bug. It was a type system mismatch.

I could:

-   Rewrite everything to JSX (huge lift)
    
-   Disable strict mode (nope)
    
-   Spam the codebase with as any (worse)
    

But Iâ€™m still an engineer. So I asked: *whatâ€™s actually happening here?*

And then I fixed it.

* * *

### âœ… The Fix: Typed Abstractions Over Factories

Instead of rewriting everything or giving up on strict mode, I built a small helper layer:

Each function wraps React.createElement but preserves type inference (when possible) and gives me guardrails â€” without forcing JSX.

Once this was in place, I refactored ~300 usages across the codebase.

**TypeScript errors dropped from 1,096 to 8.**

No JSX required. No safety lost. Just a little more intentionality.

* * *

### ðŸª And Then I Realized: I Accidentally Rebuilt Shopify

Once the architecture stabilized, I stepped back.

I noticed the pattern looked a lot like what Shopify Hydrogen, BigCommerce, and even WordPress block editors do under the hood.

Feature Shopify / BigCommerce My App Schema-based layout composition âœ… âœ… (brackets â†’ component trees) Theme + variant styling systems âœ… (Hydrogen, Polaris, CVA) âœ… (CVA + mode-aware logic) Programmatic component factories âœ… âœ… (typedElement wrappers) JSX everywhere Often abstracted away Intentionally avoided Type-safe UI rendering âŒ often loosely typed âœ… enforced with helpers

The only difference is: **they abstracted it** I kept it visible and AI-compatible.

It wasnâ€™t meant to be clever â€” it was just me trying to keep things understandable while working with the tools I had.

* * *

### ðŸ§  What I Learned

-   I donâ€™t need to be a React expert to build solid UI infrastructure.
    
-   JSX is a great DX tool â€” but not always the best for AI-generated, runtime-driven layouts.
    
-   React.createElement isnâ€™t wrong â€” itâ€™s just raw. It needs help to be safe.
    
-   TypeScriptâ€™s type system isnâ€™t broken â€” it just needs nudges when inference falls apart.
    
-   And as a backend engineer, I can bring real strengths into the frontend â€” as long as I take time to understand what the AI is giving me and hold it up to the intent of the system.
    

* * *

### ðŸš€ What Happens Next

-   Iâ€™m keeping the helper system (typedElement, typedIntrinsic, etc.)
    
-   Iâ€™ve added ESLint rules to block direct React.createElement() calls
    
-   Iâ€™ll write codemods to convert parts of the codebase to JSX later â€” if and when it improves DX
    
-   Iâ€™m documenting this pattern so future AI usage stays clean and safe
    

This isnâ€™t a workaround. This is what happens when you blend:

-   AI-assisted scaffolding
    
-   TypeScript strictness
    
-   Programmatic rendering
    
-   And an engineerâ€™s intent to **understand and stabilize the result**
    

* * *

### ðŸ§¬ TL;DR

> I didnâ€™t set out to avoid JSX. I just followed the structure AI gave me â€” then built the safety rails myself.

And in doing that, I accidentally rebuilt the UI composition pattern used by modern commerce platforms â€” just with more transparency, and less team.

* * *

Want the helpers? I'll be publishing typedElement.ts soon.

Trying to build with AI? Just remember: **You donâ€™t need to know the frontend inside out â€” you just need to know your system.**

Thatâ€™s how you keep control.